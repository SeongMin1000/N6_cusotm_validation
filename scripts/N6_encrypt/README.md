
# Overview

This directory contains an example of an end-to-end process for encrypting weights.

The example is based on a communication protocol (described with protobuf) used
to send data from a host computer to an embedded target running a Neural-Art
accelerator.

After specifying encryption parameters (keys, number of rounds), the unencrypted
data is sent to the board.
The data is encrypted by the Neural-Art accelerator on board and sent back
to the host computer.

# Quickstart
The provided toolsuite can be easily integrated into the "usual" flow when
generating code to be used on STM32N6 with Neural-Art. This adds an additional
step to the standard process:
- `stedgeai generate`
- *Encrypt weights*
- `n6_loader`
- (`stedgeai validate`)

## Generate
When calling `stedgeai generate` for stm32n6 with `--st-neural-art` option, the 
profile used shall contain `--encrypt-weights` in the options for the compiler.

This step will generate a bunch of files (`.c` file, `.raw` initializers, and
`c_info.json` file) in a target *output* directory.

## Encrypt weights
After installing the requirements described in sections below, the encryption
scripts can be called as follows (this will backup and replace at most one 
`.raw` initializer file).

Assume `network_atonbuf.xSPI2.raw` is the name of the memory initializer
that contains memory initializer for weights located in external flash,
the basic way of calling the end-to-end script is as follows:  

```
# In the "python" directory"
python end_to_end_encrypt.py <output_dir>/network_c_info.json <output_dir>/network_atonbuf.xSPI2.raw --cubeide "C:/ST/STM32CubeIDE" --postprocess
```

This will load the encryption firmware to a connected STM32N6-DK (or Nucleo) board, and send 
weights for encryption to the board. The python program will then receive encrypted weights and dump
them to the initial file (backuping the un-encrypted weights initializer).

## n6_loader
Calling the script with the `--postprocess` option ensures that the `n6_loader` script will then
process correctly all the files needed.

The `n6_loader` script can then be called, as usual.

# Detailed information about the toolsuite

## Hardware
This example is made to run on STM32N6-DK.

## Python

### Usage
A python script is used to send a file containing data to encrypt to the board,
receive encrypted data and dump the encrypted data on disk.

Python is also used to generate bindings for python and embedded-C for the communication protocol
with the help of protobuf/nanopb.

### Requirements

- python>=3.9
- pyserial>=3.5
- protobuf>=3.20.3
- tqdm>=4.64

For generating/modifying python/c bindings for the protocol defined, extra modules are needed:
- protobuf>=5.29.3
- grpcio-tools
- nanopb==0.4.9.1 (download it from [here](https://jpa.kapsi.fi/nanopb/download/))

## Firmware

### Usage
The firmware is used to receive orders from the host computer, process the data
and send it back as fast as possible to the host computer.

### Requirement
A CubeIDE project is provided. As such, STM32CubeIDE for N6 (eg. v.1.17.0+) is required.

# Performing encoding 
## Embedded program
The base program was generated using CubeMX. (see the .ioc file for reference)   
A side-effect is that "FSBL" and "appli" projects are generated, *only the FSBL
project is used in this example*.

- import the .project file into cubeIDE
- Run the FSBL project (it will wait for messages on UART @ 1,843,200 bps)

## Python

```
usage: encrypt_neural_art.py [-h] [-v] [-k KEYS KEYS] [-r NBROUNDS] [-p COMPORT] c_info raw_file

Simple python script to encrypt data (To be used with a running encryption firmware connected by an STLink)

positional arguments:
  c_info                json file output of the compilation
  raw_file              memory-initializer file output of the compilation (.raw)

optional arguments:
  -h, --help            show this help message and exit
  -v, --verbose         Increase output verbosity (debug) (default: False)
  -k KEYS KEYS, --keys KEYS KEYS
                        Keys to use (MSB LSB) (default: ['0xAABBCCDDAABBCCDD', '0xAABBCCDDAABBCCDD'])
  -r NBROUNDS, --nbrounds NBROUNDS
                        Number of rounds (ignored for now) (default: 12)
  -p COMPORT, --comport COMPORT
                        COM-port name to be used for transmitting data to STLink. auto tries to connect to the first "STLink" found. (default: auto)
```

Two arguments are mandatory (others can be omitted and default values will be used).  
- The `c_info` argument is the "c_info.json" file generated by the frontend (it contains cues on where the weights of the network are located).
- the `raw_file` argument shall point to a `.raw` file generated by the frontend (it contains the weights, unencrypted)

**Limitation: Only one memory initializer (raw file) located at address in range [0x7000_0000, 0x7800_0000] is supported by this script** (eg. weights are placed in external flash, one memory pool).


### How it works
The `c_info` argument is used by the program to check where the `.raw` weights-file is located in memory, and more precisely
what part of this file should be encrypted.  
The encryption algorithm produces different outputs based on where the data is located in memory, so this information is a must-have.

Once basic checks are performed, the script:
- Sends encryption settings (keys, ...) to the embedded program
- Splits the data file into chunks and send them to the encrypting firmware (as fast as the firmware allows)
- In the meantime, receives encrypted chunks from the encrypting firmware and writes them to the output file.

# A bit more context: how to perform encryption (end-to-end)
## Compiler
In order to use encryption, the compiler must know that the weights the Neural-Art accelerator will read will be 
encrypted, and should be decrypted on-the-fly.
This is done by calling the neural-art compiler with the `--encrypt-weights` option.

## Weights encryption
Calling the compiler will generate raw binary files with weights unencrypted.  
The weights shall be encrypted (using the tools from this article) before being flashed into the final board.

## Final firmware modifications for encryption
In the final firmware (that will perform an inference, using encrypted weights), the hardware should be 
configured before doing an inference to know how to perform decryption of the weights.

Encryption utils are located in the `ll_aton_cipher.c` that must be added to the source files to be compiled.

Modification in the code should also be done to perform proper decryption:
```
#include "ll_aton_cipher.h"       // Add cipher facilities
// Neural-Art encryption configuration (Bus interface keys - lsb/msb)
#define BUSIF_LSB_KEY      0xAABBCCDDAABBCCDD
#define BUSIF_MSB_KEY      0xAABBCCDDAABBCCDD

// Set bus interface keys -- used for encrypted inference only
LL_Busif_SetKeys ( 0 , 0 , BUSIF_LSB_KEY , BUSIF_MSB_KEY );   // Bus interface 0 / key 0
LL_Busif_SetKeys ( 0 , 1 , BUSIF_LSB_KEY , BUSIF_MSB_KEY );   // Bus interface 0 / key 1
LL_Busif_SetKeys ( 1 , 0 , BUSIF_LSB_KEY , BUSIF_MSB_KEY );   // Bus interface 1 / key 0
LL_Busif_SetKeys ( 1 , 1 , BUSIF_LSB_KEY , BUSIF_MSB_KEY );   // Bus interface 1 / key 1
```

By default, in the current versions of the Neural-Art drivers, most of the encryption settings are fixed:
- Encryption ID = 0   (original "salt" for the encryption algorithm)
- Increment step = 0  (increment of the ID above when encrypting/decrypting)
- Key selected = 0    (2 keys are available per bus interface)
- Number of rounds of the encryption algorithm = 12
Bus interface used depends on the stream engine used to perform each transfer (STRENG0-4 use bus interface 0, STRENG5-9 use bus interface 1)

# Extra: Generating python/C bindings

**This part is here just for information, it is not needed to re-compile the `proto` file ! except for making the whole project evolve**


The `.proto` file provided can be used for `nanopb`. Nanopb syntax extends the protobuf legacy syntax (providing extra
constraints/information on the c-code generated).

As such, the original file can be used to generate c-bindings without modifications but it is needed to remove some parts
of the `.proto` file (nanopb-specific parts) to be able to process it with the genuine protobuf compiler for generating
Python bindings.

```
# Generate C-bindings
nanopb/generator/nanopb_generator.py -I <src>/ -D <src>/c/Weights_encryption/nanopb_outputs/ <src>/message.proto
# Generate Python bindings
grpc_tools/protoc.py --python_out=<src>/python/pb_outputs/ --proto_path=<src>/ <src>/message.proto
```