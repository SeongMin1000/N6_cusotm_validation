__var _breakID;
__var t1;
__var t2;
__var ramname;

/* Called each time just after the reset command is issued: Restore part of the ram that may have been erased because of a reset. */
execUserReset() {
	__message "*** RESET: Re-load image partially erased by IAR reset\n";
	/* Disable RISAF2 */
    __writeMemory32(0, 0x54028040, "Memory");
    __writeMemory32(0, 0x54028080, "Memory");
    __writeMemory32(0, 0x540280C0, "Memory");
    __writeMemory32(0, 0x54028100, "Memory");
    __writeMemory32(0, 0x54028140, "Memory");
    __writeMemory32(0, 0x54028180, "Memory");
    __writeMemory32(0, 0x540281C0, "Memory");

    /* Disable SAU */
    __writeMemory32(0, 0xe000edd0, "Memory");

    /* Disable MPU */
    __writeMemory32(0, 0xe000ed24, "Memory");
	
    /* Reload image partially erased by IAR reset */
    __loadImage("$EXE_DIR$\\$TARGET_FNAME$", 0, 0);

    __restoreSoftwareBreakpoints();
}


enableExternalMem()
{
	//__message "*********************Enable Memory**************\n";
	//__delay(50); // delay of 50ms
	// Could be used for enabling clocks/supplies manuall by writing to registers directly
	//__writeMemory32(...);
}

t_in()
{
	t1 = __wallTime_ms();
}
t_out()
{
	t2 = __wallTime_ms();
	__message "*** Restore done (",t2 - t1, "ms). Continuing...\n";
}

/* Executed just before the main */
execUserPreload()
{
	enableExternalMem();
}

execUserSetup()
{
	__message "*** Finished User setup phase. Setting BPX at end of init...\n";
    _breakID = __setCodeBreak("{main.c}.##BREAKLINE##.0", 0, "1", "TRUE", "InitMem()");
}

InitMem()
{

  __clearBreak( _breakID );
  __message "\n*** Reached end of init: Restoring memory and erasing BPX\n";
## t_in(); __message "*** Restoring ##RAMNAME##";__memoryRestore("Memory", "##RAMFILE##", 0); t_out();
}

/* When the user starts/resumes the execution */
execUserExecutionStarted()
{

}